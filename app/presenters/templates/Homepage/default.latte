{block content}
<div class="container">

	<div id="editor-wrap">
		<div id="controls-panel" class="text-center">
			<button class="pull-left"><i class="fa fa-remove"></i></button>
			<button onclick="send({link send!})">SEND</button>
			<a href="{link default}" class="pull-right">
				<button>SKIP</button>
			</a>
		</div>
		<div id="editor-area"></div>
	</div>
	<script>
		$(function () {
//			$('#editor-area').awesomeCursor('pencil');
		});
	</script>

<script n:if="isset($points)">
//Width and height
var w = h = 800;
var axisPadding = 0;
var dataPadding = 30;
var g = null;
var pathIdIterator = 0;
var lineIdIterator = 0;
var paths = [];
var nodes = [];
var nodesIdIterator = 0;
var lineCoords = [];
var LINE_SNAPPING_DIST = 30;
var canvasState = "DRAW";


var dataset = {$points};

//Create scale functions
var xScale = d3.scale.linear()
	.domain([d3.min(dataset, function(d) { return d[0]; }), d3.max(dataset, function(d) { return d[0]; })])
	.range([0 + dataPadding, w - dataPadding]);

var yScale = d3.scale.linear()
	.domain([d3.min(dataset, function(d) { return d[1]; }), d3.max(dataset, function(d) { return d[1]; })])
	.range([0 + dataPadding, h - dataPadding]);


var copy, coords = [];


//Create SVG element
var svg = d3.select("#editor-area")
				.append("svg")
				.attr("width", w)
				.attr("height", h)
				.on("mousedown", mousedown)
				.on("mouseup", mouseup);

line = d3.svg.line();

function mousedown() {
	if (canvasState != "DRAW") return;

	var m = d3.mouse(this);

	if (lineCoords.length && Math.sqrt(Math.pow(m[0]-lineCoords[0][0], 2) + Math.pow(m[1]-lineCoords[0][1], 2)) < LINE_SNAPPING_DIST) {
		terminatePath();
		lineCoords.length = 0;
		return;
	}

	lineCoords.push([m[0], m[1]]);

	line = svg.select("g").append("line")
					.attr("x1", m[0])
					.attr("y1", m[1])
					.attr("x2", m[0])
					.attr("y2", m[1])
					.attr("class", "path-"+pathIdIterator+" start-node-"+lineIdIterator+" end-node-"+(lineIdIterator+1));
	lineIdIterator++;

	svg.on("mousemove", mousemove);
}

function mousemove() {
	if (canvasState != "DRAW") return;
	if (!lineCoords.length) return;

	var m = d3.mouse(this);
	var endCoords = [m[0], m[1]];

	if (Math.sqrt(Math.pow(m[0]-lineCoords[0][0], 2) + Math.pow(m[1]-lineCoords[0][1], 2)) < LINE_SNAPPING_DIST) {
		endCoords[0] = lineCoords[0][0];
		endCoords[1] = lineCoords[0][1];
	}

	line.attr("x2", endCoords[0])
					.attr("y2",endCoords[1]);

	dot.each(function(d, i) {
		point = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
		if (pointInPolygon(point, lineCoords)) {
			d3.select(this).classed("selected", true)
		}
	});
}

function terminatePath() {
	line.attr("x2", lineCoords[0][0])
					.attr("y2",lineCoords[0][1])
					.attr("class", "path-"+pathIdIterator +" start-node-"+ (lineIdIterator-1) +" end-node-0");

	for (var i = 0; i < lineCoords.length; i++) {
		var point = g.append("svg:circle")
						.style("fill", "white")
						.attr("r", 6)
						.attr("stroke", "#000")
						.attr("stroke-width", "2")
						.attr("cx", lineCoords[i][0])
						.attr("cy", lineCoords[i][1])
						.attr("class", "node path-"+pathIdIterator+" node-"+i)
						.call(nodeDrag);

		nodes.push(point);
	}
	pathIdIterator++;
	lineIdIterator = 0;
}

function mouseup() {
//	svg.on("mousemove", null);
}

var nodeDrag = d3.behavior.drag();

nodeDrag.on("dragstart", function() {
	d3.event.sourceEvent.stopPropagation(); // silence other listeners
	console.log('drag-start');
});

nodeDrag.on("drag", function() {
	d3.event.sourceEvent.stopPropagation(); // silence other listeners

	var classes = d3.select(this).attr("class").split(" ");
	var pathId = classes[1];
	var nodeId = classes[2];

	console.log('drag', pathId, nodeId);

	var m = d3.mouse(this);
	d3.select(this).attr({
		cx: m[0],
		cy: m[1]
	});

	var startLine = d3.select("line."+pathId+".start-"+nodeId);
	var endLine = d3.select("line."+pathId+".end-"+nodeId);

	console.log(startLine.attr("x1"), startLine.attr("y1"),startLine.attr("x2"), startLine.attr("y2"));
	console.log(endLine.attr("x1"), endLine.attr("y1"),endLine.attr("x2"), endLine.attr("y2"));

	startLine.attr("x1",m[0])
					.attr("y1",m[1]);

	endLine.attr("x2",m[0])
					.attr("y2",m[1]);
});

nodeDrag.on("dragend", function() {
	d3.event.sourceEvent.stopPropagation(); // silence other listeners
	console.log('drag-end');
});

dot = svg.selectAll("circle")
	.data(dataset)
	.enter()
	.append("circle")
	.attr("fill", "#f00")
//	.attr("stroke", "#000")
	.attr("cx", function(d) {
		return xScale(d[0]);
	})
	.attr("cy", function(d) {
		return -yScale(d[1]) + h;		//inverse Y axis and move it down according to canvas height
	})
	.attr("r", 2);

g = svg.append("g");

//console.log('minX',d3.min(dataset, function(d) { return d[0]; }));
//console.log('maxX',d3.max(dataset, function(d) { return d[0]; }));
//console.log('minY',d3.min(dataset, function(d) { return d[1]; }));
//console.log('maxY',d3.max(dataset, function(d) { return d[1]; }));

// from https://github.com/substack/point-in-polygon
pointInPolygon = function (point, vs) {
	// ray-casting algorithm based on
	// http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	var xi, xj, i, intersect,
		x = point[0],
		y = point[1];
	inside = false;
	for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
		xi = vs[i][0],
			yi = vs[i][1],
			xj = vs[j][0],
			yj = vs[j][1];
		intersect = ((yi > y) != (yj > y))
		&& (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
		if (intersect) inside = !inside;
	}
	return inside;
};

d3.select("#clear").on("click", function() {
	dot.classed("selected", false);
	dragStart();
})

send = function(urlPath) {
	var paths = [];
	$("#editor-area svg g .terminator").each(function(){
		var path = $(this).prev().attr('d') + $(this).attr('d');
		paths.push(path);
	});
	console.log(paths);

	var hashTags = JSON.stringify(paths);
	$.ajax({
		url: urlPath,
		method: 'POST',
		data: { paths: paths, dataId: {$dataId} },
		beforeRegquest: function() {
			alert('Do you really want to send?');
		}
	});
}



</script>

</div><!-- /.container -->
